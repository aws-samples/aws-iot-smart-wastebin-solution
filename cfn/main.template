AWSTemplateFormatVersion: "2010-09-09"

Description: Creates a smart bin demo app

Metadata:
  Version: 0.1.0

Parameters:
  ProjectName:
    Description: The name of the project. The name must only contain alphanumeric characters.
    Type: String
    Default: smart-bin-demo-app
    AllowedPattern: '[a-zA-Z0-9_-]*'
    ConstraintDescription: Must contain only alphanumeric characters.

  ResourcePrefix:
    Description: AWS Resources are named based on the value of this parameter. You must customise this if you are launching more than one instance of the stack within the same account.
    Type: String
    Default: demo
    AllowedPattern: ^[a-zA-Z0-9_]*$

  ArtefactsBucketName:
    Description: S3 bucket name for the assets. Artefacts bucket name can include numbers, lowercase letters, uppercase letters, and hyphens (-). It cannot start or end with a hyphen (-).
    Type: String
    AllowedPattern: ^[0-9a-zA-Z]+([0-9a-zA-Z-.]*[0-9a-zA-Z])*$
    ConstraintDescription: Artefacts bucket name can include numbers, lowercase letters, uppercase letters, periods (.), and hyphens (-). It cannot start or end with a hyphen (-).

Resources:
  RoleAliasProvisionerRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${ResourcePrefix}-RoleAliasProvisionerRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: lambda.amazonaws.com
      Description: Execution role for the RoleAlias custom resource Lambda
      Policies:
        - PolicyName: !Sub ${ResourcePrefix}-RoleAliasProvisionerPermissions
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Resource: '*'
                Action:
                  - iot:CreateRoleAlias
                  - iot:UpdateRoleAlias
                  - iot:DeleteRoleAlias
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - iam:PassRole

  RoleAliasProvisioner:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ResourcePrefix}-RoleAliasProvisioner
      Architectures: [arm64]
      Runtime: python3.9
      Description: Custom resource handler to provision a IoT role alias from CloudFormation
      Role: !GetAtt RoleAliasProvisionerRole.Arn
      Handler: index.handler
      Code:
        ZipFile: |
          import cfnresponse
          import boto3
          import logging
          def handler(event, context):
            logging.getLogger().setLevel(logging.INFO)
            logging.info(f'Processing event: {event} | with context: {context}')
            result, data, id = cfnresponse.FAILED, {}, None
            try:
                request_type = event['RequestType']
                alias = event['ResourceProperties']['Alias']
                role = event['ResourceProperties']['Role']
                client = boto3.client('iot')
                if request_type == 'Create':
                    data = client.create_role_alias(roleAlias=alias, roleArn=role)
                    id = data['roleAliasArn']
                elif request_type == 'Update':
                    data = client.update_role_alias(roleAlias=alias, roleArn=role)
                    id = data['roleAliasArn']
                elif request_type == 'Delete':
                    data = client.delete_role_alias(roleAlias=alias)
                result = cfnresponse.SUCCESS
            except Exception as ex:
                logging.exception(ex)
            cfnresponse.send(event, context, result, data, id)

  CertificateProvisionerRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${ResourcePrefix}-CertificateProvisionerRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: lambda.amazonaws.com
      Description: Execution role for the RoleAlias custom resource Lambda
      Policies:
        - PolicyName: RoleAliasProvisionerPermissions
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Resource: '*'
                Action:
                  - iot:CreateKeysAndCertificate
                  - iot:UpdateCertificate
                  - secretsmanager:DescribeSecret
                  - secretsmanager:GetSecretValue
                  - secretsmanager:PutSecretValue
                  - secretsmanager:UpdateSecretVersionStage
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents

  CertificateProvisioner:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ResourcePrefix}-CertificateProvisioner
      Architectures: [arm64]
      Runtime: python3.9
      Description: Rotation function to generate IoT certificates via Secrets Manager
      Role: !GetAtt CertificateProvisionerRole.Arn
      Handler: index.handler
      Code:
        ZipFile: |
          import boto3
          import json
          import logging
          import urllib3
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          def handler(event, context):
              try:
                  arn = event['SecretId']
                  token = event['ClientRequestToken']
                  client = boto3.client('secretsmanager')
                  metadata = client.describe_secret(SecretId=arn)
                  if not metadata['RotationEnabled']:
                      raise ValueError("Secret %s is not enabled for rotation" % arn)
                  versions = metadata['VersionIdsToStages']
                  if token not in versions:
                      raise ValueError("Secret version %s has no stage for rotation of secret %s." % (token, arn))
                  if "AWSCURRENT" in versions[token]:
                      logger.info("Secret version %s already set as AWSCURRENT for secret %s." % (token, arn))
                      return
                  if "AWSPENDING" not in versions[token]:
                      raise ValueError("Secret version %s not set as AWSPENDING for rotation of secret %s." % (token, arn))
                  step_handlers[event['Step']](client, arn, token)
              except:
                  logging.exception(f'Exception processing event: {event} with context: {context}')
                  raise
          def create_secret(client, arn, token):
              client.get_secret_value(SecretId=arn, VersionStage="AWSCURRENT")
              try:
                  client.get_secret_value(SecretId=arn, VersionId=token, VersionStage="AWSPENDING")
                  logger.info("createSecret: Successfully retrieved secret for %s." % arn)
              except client.exceptions.ResourceNotFoundException:
                  iot = boto3.client('iot')
                  response = iot.create_keys_and_certificate(setAsActive=True)
                  secret = {
                    'certificateArn': response['certificateArn'],
                    'certificateId': response['certificateId'],
                    'certificate': response['certificatePem'],
                    'publicKey': response['keyPair']['PublicKey'],
                    'privateKey': response['keyPair']['PrivateKey']
                  }
                  client.put_secret_value(SecretId=arn, ClientRequestToken=token, SecretString=json.dumps(secret), VersionStages=['AWSPENDING'])
                  logger.info("createSecret: Successfully put secret for ARN %s and version %s." % (arn, token))
          def set_secret(client, arn, token):
              pass
          def test_secret(client, arn, token):
              pass
          def finish_secret(client, arn, token):
              metadata = client.describe_secret(SecretId=arn)
              current_version = None
              for version in metadata["VersionIdsToStages"]:
                  if "AWSCURRENT" in metadata["VersionIdsToStages"][version]:
                      current_version = version
                      break
              if current_version == token:
                  logger.info("finishSecret: Version %s already marked as AWSCURRENT for %s" % (version, arn))
                  return
              old_value = json.loads(client.get_secret_value(SecretId=arn, VersionStage="AWSCURRENT")['SecretString'])
              # Set the new cert as current
              client.update_secret_version_stage(SecretId=arn, VersionStage="AWSCURRENT", MoveToVersionId=token, RemoveFromVersionId=current_version)
              logger.info(f'finishSecret: Successfully set AWSCURRENT stage to version {token} for secret {arn}')
              # Signal Cloudformation if required
              logger.info(f'finishSecret: {old_value}')
              if 'waitHandle' in old_value:
                logger.info(f'signalling: {old_value["waitHandle"]}')
                urllib3.PoolManager().request(
                    'PUT',
                    old_value['waitHandle'],
                    headers={'Conent-Type': ''},
                    body=json.dumps({
                        'Status' : 'SUCCESS',
                        'UniqueId' : '1',
                        'Data' : '',
                        'Reason' : ''
                    }).encode('utf-8')
                )
              # Deactivate the old cert
              if 'certificateId' in old_value:
                iot = boto3.client('iot')
                iot.update_certificate(certificateId=old_value['certificateId'], newStatus='INACTIVE')
          step_handlers = {
              'createSecret': create_secret,
              'setSecret': set_secret,
              'testSecret': test_secret,
              'finishSecret': finish_secret
          }

  InvocationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref CertificateProvisioner
      Principal: secretsmanager.amazonaws.com

  FleetProvisioningRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${ResourcePrefix}-FleetProvisioningRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: iot.amazonaws.com
      Description: Used for provisioning new greengrass core devices
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSIoTThingsRegistration

  TokenExchangeRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${ResourcePrefix}-TokenExchangeRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: credentials.iot.amazonaws.com
      Description: Greengrass core devices assume this role to access AWS resources
      ManagedPolicyArns:
        - !Ref TokenExchangePolicy

  TokenExchangePolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Permissions required for Greengrass token exchange
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Resource: '*'
            Action:
              - iot:DescribeCertificate
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
              - logs:DescribeLogStreams
              - s3:GetBucketLocation
              - s3:*

  TokenExchangeRoleAlias:
    Type: Custom::IotRoleAlias
    Properties:
      ServiceToken: !GetAtt RoleAliasProvisioner.Arn
      Role: !GetAtt TokenExchangeRole.Arn
      Alias: GreengrassTokenExchangeAlias

  CoreDeviceAccessPolicy:
    Type: AWS::IoT::Policy
    Properties:
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Resource: '*'
            Action:
              - iot:Publish
              - iot:Subscribe
              - iot:Receive
              - iot:Connect
              - greengrass:*
              - S3:*
          - Effect: Allow
            Resource: !GetAtt TokenExchangeRoleAlias.roleAliasArn
            Action: iot:AssumeRoleWithCertificate

  GreengrassProvisioningPolicy:
    Type: AWS::IoT::Policy
    Properties:
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Resource: '*'
            Action: iot:Connect
          - Effect: Allow
            Resource:
              - !Sub arn:aws:iot:${AWS::Region}:${AWS::AccountId}:topic/$aws/certificates/create/*
              - !Sub arn:aws:iot:${AWS::Region}:${AWS::AccountId}:topic/$aws/provisioning-templates/${FleetProvisioningTemplate}/provision/*
            Action:
              - iot:Publish
              - iot:Receive
          - Effect: Allow
            Resource:
              - !Sub arn:aws:iot:${AWS::Region}:${AWS::AccountId}:topicfilter/$aws/certificates/create/*
              - !Sub arn:aws:iot:${AWS::Region}:${AWS::AccountId}:topicfilter/$aws/provisioning-templates/${FleetProvisioningTemplate}/provision/*
            Action: iot:Subscribe

  FleetProvisioningTemplate:
    Type: AWS::IoT::ProvisioningTemplate
    Properties:
      Description: Template to provision waste bins as IoT things
      Enabled: true
      ProvisioningRoleArn: !GetAtt FleetProvisioningRole.Arn
      TemplateBody: !Sub |
        {
          "Parameters": {
            "ThingName": { "Type": "String" },
            "SerialNumber" : {
                  "Type" : "String"
              },
            "Location" : {
                  "Type" : "String",
                  "Default" : "UK"
              },
            "AWS::IoT::Certificate::Id": { "Type": "String" }
          },
          "Resources": {
            "ThingDefinition": {
              "OverrideSettings": {
                "AttributePayload": "REPLACE",
                "ThingGroups": "REPLACE",
                "ThingTypeName": "REPLACE"
              },
              "Properties": {
                "AttributePayload": {"serialNumber" :  {"Ref" : "SerialNumber"},
                "location" :  {"Ref" : "Location"}},
                "ThingName": { "Ref": "ThingName" }
              },
              "Type": "AWS::IoT::Thing"
            },
            "ThingPolicy": {
              "Properties": { "PolicyName": "${CoreDeviceAccessPolicy}" },
              "Type": "AWS::IoT::Policy"
            },
            "ThingCertificate": {
              "Properties": {
                "CertificateId": { "Ref": "AWS::IoT::Certificate::Id" },
                "Status": "Active"
              },
              "Type": "AWS::IoT::Certificate"
            }
          }
        }

  CertificateWaitHandle:
    Type: AWS::CloudFormation::WaitConditionHandle
    Properties: {}

  CertificateWaitCondition:
    Type: AWS::CloudFormation::WaitCondition
    DependsOn: CertificateRotationSchedule
    Properties:
      Count: 1
      Handle: !Ref CertificateWaitHandle
      Timeout: "60"

  CertificateSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Greengrass fleet provisioning certificate and key info
      SecretString: !Sub '{ "waitHandle": "${CertificateWaitHandle}" }'

  CertificateRotationSchedule:
    Type: AWS::SecretsManager::RotationSchedule
    Properties:
      RotationLambdaARN: !GetAtt CertificateProvisioner.Arn
      RotationRules:
        AutomaticallyAfterDays: 365
      SecretId: !Ref CertificateSecret

  CertificateAttachment:
    Type: AWS::IoT::PolicyPrincipalAttachment
    DependsOn: CertificateWaitCondition
    Properties:
      PolicyName: !Ref GreengrassProvisioningPolicy
      Principal: !Sub '{{resolve:secretsmanager:${CertificateSecret}::certificateArn}}'

  IdentifyWasteTypeRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${ResourcePrefix}-IdentifyWasteTypeRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: lambda.amazonaws.com
      Description: Execution role for the RoleAlias custom resource Lambda
      Policies:
        - PolicyName: !Sub ${ResourcePrefix}-IdentifyWasteTypePermissions
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Resource: '*'
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - rekognition:*
                  - s3:Get*
                  - s3:List*
                  - s3-object-lambda:Get*
                  - s3-object-lambda:List*

  IoTAnalyticsPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt IdentifyWasteType.Arn
      Action: lambda:InvokeFunction
      Principal: iotanalytics.amazonaws.com

  IdentifyWasteType:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ResourcePrefix}-IdentifyWasteType
      Architectures: [arm64]
      Runtime: python3.9
      Description: Custom resource handler to provision a IoT role alias from CloudFormation
      Role: !GetAtt IdentifyWasteTypeRole.Arn
      Handler: index.lambda_handler
      Timeout: 20
      MemorySize: 128
      Code:
        ZipFile: |
          import json
          import boto3
          import time
          import datetime
          def get_event_date(event):
            if "timestamp" in event[0]:
              mytimestamp = datetime.datetime.fromtimestamp( event[0]["timestamp"] )
            else:
              mytimestamp = datetime.datetime.fromtimestamp( time.time() )
            return mytimestamp.strftime( "%Y%m%d")
          def lambda_handler(event, context):
              if len(event) > 0 and "s3_image_uri" in event[0]:
                  print(event)
                  bucket_url=event[0]["s3_image_uri"]
                  output=bucket_url.split("/",3)
                  bucket=output[2]
                  photo=output[3]
                  client=boto3.client('rekognition')
                  #process using S3 object
                  try:
                      time.sleep(5)
                      # If using custom models, then please use below syntax
                      #response = client.detect_custom_labels(Image={'S3Object': {'Bucket': bucket, 'Name': photo}},
                      #MinConfidence=30,ProjectVersionArn=model_arn)
                      response = client.detect_labels(Image={'S3Object':{'Bucket':bucket,'Name':photo}},MaxLabels=10)
                  except Exception as ex:
                      print(ex)
                      event[0]["sorted_waste"] = []
                      event[0]["organic_waste"] = 0
                      event[0]["solid_waste"] = 0
                      event[0]["hazardous_waste"] = 0
                      event[0]["other_waste"] = 0
                      return event
                  #Get the custom labels
                  #labels=response['CustomLabels']
                  labels=response['Labels']
                  solid_waste=0
                  organic_waste=0
                  hazardous_waste=0
                  other_waste=0
                  sorted_waste_items=[]
                  organic_waste_dict=["orange","bread","banana","orange peel","apple","onion","vegatable","potato"]
                  solid_waste_dict=["cardboard","plastic","paper","bottle","polethene","paper ball"]
                  hazardous_waste_dict=["batteries"]
                  for label in labels:
                      if label["Name"] in organic_waste_dict:
                          organic_waste+=1
                      elif label["Name"] in solid_waste_dict:
                          solid_waste+=1
                      elif label["Name"] in hazardous_waste_dict:
                          hazardous_waste+=1
                      else:
                          other_waste+=1
                      if label["Name"] not in sorted_waste_items:
                          sorted_waste_items.append(label["Name"])
                  event[0]["sorted_waste"] = sorted_waste_items
                  event[0]["organic_waste"] = organic_waste
                  event[0]["solid_waste"] = solid_waste
                  event[0]["hazardous_waste"] = hazardous_waste
                  event[0]["other_waste"] = other_waste
                  event[0]["event_date"] = get_event_date(event)
                  print(event)
              else:
                  sorted_waste_items=[]
                  event[0]["sorted_waste"] = sorted_waste_items
                  event[0]["organic_waste"] = 0
                  event[0]["solid_waste"] = 0
                  event[0]["hazardous_waste"] = 0
                  event[0]["other_waste"] = 0
                  event[0]["event_date"] = get_event_date(event)
              return event

  TrashBinS3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  TrashBinS3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref TrashBinS3Bucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Resource:
              - !Sub arn:aws:s3:::${TrashBinS3Bucket}
              - !Sub arn:aws:s3:::${TrashBinS3Bucket}/*
            Principal:
              Service: iotanalytics.amazonaws.com
            Action:
              - s3:GetBucketLocation
              - s3:GetObject
              - s3:ListBucket
              - s3:ListBucketMultipartUploads
              - s3:ListMultipartUploadParts
              - s3:AbortMultipartUpload
              - s3:PutObject
              - s3:DeleteObject

  IoTAnalyticsS3Role:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${ResourcePrefix}-IoTAnalyticsS3Role
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - iotanalytics.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: !Sub ${ResourcePrefix}-iot-analytics-role-policy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetBucketLocation
                  - s3:GetObject
                  - s3:ListBucket
                  - s3:ListBucketMultipartUploads
                  - s3:ListMultipartUploadParts
                  - s3:AbortMultipartUpload"
                  - s3:PutObject
                  - s3:DeleteObject
                Resource:
                  - !GetAtt TrashBinS3Bucket.Arn
                  - !Sub ${TrashBinS3Bucket.Arn}/*

  Channel:
    Type: AWS::IoTAnalytics::Channel
    Properties:
      ChannelName: !Sub ${ResourcePrefix}_trash_channel
      ChannelStorage:
        CustomerManagedS3:
          Bucket: !Sub ${TrashBinS3Bucket}
          RoleArn: !GetAtt IoTAnalyticsS3Role.Arn
      Tags:
        - Key: name
          Value: smart-bin-demo

  Datastore:
    Type: AWS::IoTAnalytics::Datastore
    Properties:
      DatastoreName: !Sub ${ResourcePrefix}_trash_datastore
      DatastoreStorage:
        CustomerManagedS3:
          Bucket: !Sub ${TrashBinS3Bucket}
          RoleArn: !GetAtt IoTAnalyticsS3Role.Arn
      Tags:
        - Key: name
          Value: smart-bin-demo

  Pipeline:
    Type: AWS::IoTAnalytics::Pipeline
    Properties:
      PipelineName: trash_pipeline
      PipelineActivities:
        - Channel:
            Name: trash_channel_activity
            ChannelName: !Sub ${Channel}
            Next: IdentifyWasteType
          Lambda:
            Name: IdentifyWasteType
            LambdaName: !Sub ${IdentifyWasteType}
            BatchSize: 1
            Next: trash_datastore_activity
          Datastore:
            DatastoreName: !Sub ${Datastore}
            Name: trash_datastore_activity
      Tags:
        - Key: name
          Value: smart-bin-demo

  Dataset:
    Type: AWS::IoTAnalytics::Dataset
    Properties:
      DatasetName: !Sub ${ResourcePrefix}_trash_dataset
      Actions:
        - ActionName: SqlAction
          QueryAction:
            SqlQuery: !Sub select * from ${Datastore}
      Triggers:
        - Schedule:
            ScheduleExpression: cron(0/15 * * * ? *)
      RetentionPeriod:
        Unlimited: false
        NumberOfDays: 10

  IoTAnalytiucsRoleForIoTCoreRule:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${ResourcePrefix}-IoTAnalytiucsRoleForIoTCoreRule
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: iot.amazonaws.com
      Description: Execution role for the RoleAlias custom resource Lambda
      Policies:
        - PolicyName: IoTCoreRulePermissions
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Resource:
                  - !Sub arn:aws:iotanalytics:${AWS::Region}:${AWS::AccountId}:channel/${Channel}
                Action:
                  - iotanalytics:BatchPutMessage

  TrashBinRule:
    Type: AWS::IoT::TopicRule
    Properties:
      RuleName: !Sub ${ResourcePrefix}_trash_data_rule
      TopicRulePayload:
        RuleDisabled: false
        Sql: SELECT * FROM 'smart/trash_bin'
        Actions:
          - IotAnalytics:
              BatchMode: false
              ChannelName: !Sub ${Channel}
              RoleArn: !GetAtt IoTAnalytiucsRoleForIoTCoreRule.Arn

  SensorApp:
    Type: AWS::GreengrassV2::ComponentVersion
    Properties:
      InlineRecipe: !Sub |
        ComponentConfiguration:
          DefaultConfiguration:
            accessControl:
              aws.greengrass.ipc.mqttproxy:
                monitor_wastebin_app:mqttproxy:1:
                  operations:
                  - aws.greengrass#PublishToIoTCore
                  resources:
                  - smart/trash_bin
        ComponentDescription: Uses stream manager to upload a file to an S3 bucket.
        ComponentName: monitor_wastebin_app
        ComponentPublisher: sbmane@amazon.com
        ComponentVersion: 2.0.0
        Manifests:
        - Artifacts:
          - URI: s3://${ArtefactsBucketName}/${AWS::StackName}/greengrass-app-components/monitor_wastebin_app.py
          - URI: s3://${ArtefactsBucketName}/${AWS::StackName}/greengrass-app-components/image_stream.py
          - URI: s3://${ArtefactsBucketName}/${AWS::StackName}/greengrass-app-components/hx711_i2c.py
          - URI: s3://${ArtefactsBucketName}/${AWS::StackName}/greengrass-app-components/mqtt_publisher.py
          - URI: s3://${ArtefactsBucketName}/${AWS::StackName}/greengrass-app-components/sensors.py
          - URI: s3://${ArtefactsBucketName}/${AWS::StackName}/greengrass-app-components/requirements.txt
          Lifecycle:
            Install: pip3 install --user -r {artifacts:path}/requirements.txt
            Run: '
              export PYTHONPATH=$PYTHONPATH:{artifacts:decompressedPath}/stream_manager_sdk;
              python3 -u {artifacts:path}/monitor_wastebin_app.py
              '
          Platform:
            os: linux
        RecipeFormatVersion: '2020-01-25'

  TrashLables:
    Type: AWS::Rekognition::Project
    Properties:
      ProjectName: !Sub ${ProjectName}

Outputs:
  CertificateSecret:
    Description: Secret holding the generated fleet provisioning certificate and keys
    Value: !Ref CertificateSecret

  FleetProvisioningTemplate:
    Description: Name of the template to use for fleet provisioning
    Value: !Ref FleetProvisioningTemplate
    Export:
      Name: FleetProvisioningTemplate

  TrashBinS3BucketName:
    Description: Trash bin bucket name
    Value: !Ref TrashBinS3Bucket
